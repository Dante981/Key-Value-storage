# Key-Value-storage
Техническое задание: Key‑Value хранилище (аналог Redis)
1. Общее описание
Цель: разработать легковесное Key‑Value хранилище с оперативной памятью и персистентностью, поддерживающее базовые операции Redis‑подобного интерфейса.

Целевая аудитория:

разработчики микросервисов;

системные администраторы;

команды, нуждающиеся в кэше или простом хранилище состояний.

Аналоги: Redis (базовый функционал), но с упрощённой архитектурой и минимальным набором команд.

2. Функциональные требования
2.1. Основные операции
SET key value [EX seconds] — установить значение с необязательным TTL.

GET key — получить значение по ключу.

DEL key — удалить ключ.

EXISTS key — проверить существование ключа.

TTL key — вернуть оставшееся время жизни ключа (в секундах).

FLUSHALL — очистить всё хранилище.

KEYS pattern — поиск ключей по шаблону (поддержка *, ?).

2.2. Персистентность
AOF (Append-Only File): журналирование всех операций записи.

Настройка частоты сброса на диск:

всегда (always);

раз в секунду (everysec);

никогда (no).

Восстановление состояния при перезапуске из AOF.

2.3. Управление временем жизни (TTL)
Автоматическое удаление ключей по истечении TTL.

Возможность обновить TTL для существующего ключа.

Команда PEXPIRE key milliseconds — установка TTL в миллисекундах.

2.4. Ограничения памяти
Настройка максимального объёма ОЗУ (maxmemory).

Политика вытеснения: volatile-lru (удаление ключей с TTL по LRU).

3. Нефункциональные требования
3.1. Производительность
Время отклика для GET/SET: ≤ 1 мс (на стандартном железе).

Поддержка ≥ 10 000 операций/сек при нагрузке.

3.2. Надёжность
Гарантия целостности данных при корректном завершении работы.

Восстановление из AOF после аварийного завершения.

3.3. Масштабируемость
Однопоточная модель (без шардинга/репликации на первом этапе).

Поддержка ≥ 1 млн ключей в памяти.

3.4. Безопасность
Аутентификация по паролю (команда AUTH).

Ограничение доступа по IP (опционально).

3.5. Мониторинг
Команда INFO — статистика (количество ключей, использование памяти, Uptime).

Логирование операций в файл.

4. Интерфейс взаимодействия
4.1. Протокол
Текстовый протокол через TCP (аналогично Redis RESP).

Порт по умолчанию: 6379.

4.2. Формат ответов
Простые строки: +OK\r\n.

Ошибки: -Error message\r\n.

Целые числа: :<number>\r\n.

Массивы: *N\r\n (где N — количество элементов).

5. Архитектура
5.1. Компоненты
Сетевой слой — приём и обработка TCP‑соединений.

Парсер команд — разбор RESP‑запросов.

Ядро хранилища — хеш‑таблица с ключами и значениями.

Менеджер TTL — фоновый поток для проверки сроков жизни.

Модуль персистентности — запись в AOF и восстановление.

Аутентификационный модуль — проверка пароля.

5.2. Структура данных
Ключи и значения — строки (максимум 512 МБ).

Внутренняя структура: хеш‑таблица с открытой адресацией или цепным хешированием.

TTL хранится в отдельной структуре (например, min‑heap для эффективного поиска).

6. Требования к окружению
ОС: Linux (Ubuntu 20.04+/CentOS 7+), macOS, Windows (через WSL).

Язык реализации: C++/Go/Rust (высокопроизводительные) или Python (для прототипа).

Зависимости: отсутствуют (или минимальный набор библиотек).

7. Этапы разработки
** MVP (1–2 недели)**:

Реализация SET/GET/DEL/EXISTS.

Базовая персистентность (AOF).

TCP‑сервер.

Версия 1.0 (1 месяц):

Добавление TTL и FLUSHALL.

Аутентификация.

Команда INFO.

Тестирование нагрузки.

Версия 1.1 (2 месяца):

Поддержка KEYS с шаблонами.

Политика maxmemory.

Логирование.

8. Критерии приёмки
Все команды работают согласно спецификации.

Тесты покрытия ≥ 80%.

Стабильность при нагрузке (тест через redis-benchmark‑подобный инструмент).

Документация: руководство пользователя и API.

9. Ограничения и допущения
Нет поддержки репликации и шардинга.

Нет сложных структур данных (списки, хеши, множества).

Однопоточная модель (без параллелизма на запись).

10. Документация
Руководство пользователя:

Установка.

Настройка (config.json).

Примеры использования.

API‑спецификация:

Формат команд и ответов.

Коды ошибок.

Архитектура:

Схема компонентов.

Алгоритмы хранения и TTL.

11. Дополнительные требования (опционально)
Поддержка скриптов на Lua (для расширенной логики).

Метрики в формате Prometheus.

CLI‑клиент для отладки.

